( malloc.tal )

( devices )
|10 @Console &vector $2 &read $1 &pad $5 &write $1 &error $1

%PrintDigit { #30 ADD EMIT }
%PRINT_BYTE { SWP PrintNibble PrintNibble }
%NewLine { #0a .Console/write DEO }

%ToMask { #ff EOR #01 ADD }
%PrintNibble ( nibble -- ) {
    DUP LIT "0 ADD SWP
    #09 GTH ToMask
    LIT2 "a "9 #01 ADD SUB
    AND ADD .Console/write DEO
}


( init )
|0100
    #01 PrintNibble NewLine
    #01 ;print_heap JSR2
    NewLine
    #01 ;malloc JSR2
    #01 ;print_heap JSR2
    NewLine
    #02 ;malloc JSR2
    #01 ;print_heap JSR2
BRK


%TO_SHORT { #00 SWP } ( byte -- short )
%MALLOC_LOOK_UP { #0004 SUB2 } ( a -- a' )

%ISFREE {
    DUP2 SWP #00 SWP
    ;BitMap.header ADD2
    LDA AND #00 EQU
} ( ptr * -- ptr* bool )
( ptr* -- ptr* m* p* -- ptr* m* p*16    )
(      -- ptr* m* bitmap+p*16           )
(      -- ptr* m*/\bitmap[p*16]         )

%NBFREE {
    DUP #01 AND #00 EQU SWP
    DUP #03 AND #00 EQU SWP
    DUP #07 AND #00 EQU SWP
    DUP #0f AND #00 EQU SWP
    DUP #1f AND #00 EQU SWP
    DUP #3f AND #00 EQU SWP
    DUP #7f AND #00 EQU SWP
    #00 EQU
    ADD ADD ADD ADD ADD ADD ADD
}
( DUP #mask AND #00 EQU SWP :   )
( m -- m m mask -- m m&mask     )
(   -- m m&mask==0              )
(   -- m&mask==0 m              )
( ...                           )
( m&01 m&03 m&07 m&0f m&1f m&3f m&7f m )

@look_space ( n -- b i* )
    ;BitMap/pointer LDA2 ( n bmp* )
    &next_space
        ISFREE ,&found JCN ( n bmp'* )
        ;BitMap/pointer LDA2 #10 SFT EQU ( n bmp'* == bmp*"-1" )
        ,&not_found JCN ( n )
        ;incr_pointer JSR2
        ,&next_space JMP
    &not_found ( n )
        POP #0000 ( n -- 00 00 )
JMP2r
    &found
        &while


@malloc ( nb_obj -- ptr* )
    ;BitMap/pointer LDA2 ( n bmp* )
    ROT ( bmp* n )
    DUP ( n n )
    &while
        DUP #00 NEQ         ( if n != 0 then )
        MALLOC_LOOK_UP      ( ws: counter' )
        LDAk                ( ws: counter' v )
        ,&while JCN         ( ws: counter' )
    &end
    DUP             ( ws: counter counter )
    ( tag malloc )
    #01 SWP         ( ws: counter 01 counter )
    STA             ( ws: counter )
JMP2r

( un ptr* est sur 2 octets :   )
( - un pointeur p*     1 octet )
( - un mask m*         1 octet )

@incr_pointer ( p* m* -- p'* m'* )
    #01 SFT         ( p* m'*  )
    DUP ,&end JCN   ( p* m'*  )
        POP         ( p*      )
        #01 ADD     ( p'*     )
        ( p* cicle automatiquement sur 256 bits     )
        #80         ( p'* m'* )
        ( on rajoute m'* remis à la valeur initiale )
    &end
JMP2r

@BitMap
    &pointer 00         ( Last cell allocated + 1 )
    &mask 80    ( Last bit allocated + 1 )
    &header $100 ( 256 octets -> 2^11 objets addressables )
    &data $1000 ( 2^11 objets de 2 octects -> espace réservé de 2^12 octets )

